# ArgoCD Bootstrap Configuration
# Minimal configuration for initial ArgoCD deployment

global:
  domain: platform.local

# Server configuration  
server:
  service:
    type: ClusterIP
  
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 500m
      memory: 512Mi

# Application Controller
controller:
  resources:
    requests:
      cpu: 250m
      memory: 512Mi
    limits:
      cpu: 1000m
      memory: 2Gi

# Repository Server
repoServer:
  resources:
    requests:
      cpu: 100m
      memory: 256Mi
    limits:
      cpu: 1000m
      memory: 1Gi

# Redis
redis:
  enabled: true
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 500m
      memory: 512Mi

# ApplicationSet Controller
applicationSet:
  enabled: true
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 500m
      memory: 512Mi

# Notifications Controller
notifications:
  enabled: true
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 500m
      memory: 512Mi

# RBAC
rbac:
  create: true
  policy.default: role:readonly

# Configuration
configs:
  cm:
    # Resource tracking method
    application.resourceTrackingMethod: annotation
    
    # Timeout settings
    timeout.reconciliation: 180s
    timeout.hard.reconciliation: 0s
    
    # Custom health checks (simplified from KubriX)
    resource.customizations.health.argoproj.io_Application: |
      hs = {}
      hs.status = "Progressing"
      hs.message = ""
      if obj.status ~= nil then
        if obj.status.health ~= nil then
          hs.status = obj.status.health.status
          if obj.status.health.message ~= nil then
            hs.message = obj.status.health.message
          end
        end
      end
      return hs