#!/bin/bash
# configure_containerd.sh - Configure containerd for Kubernetes and container workloads
# Part of the infrastructure bootstrap system
# Used by: Kubernetes nodes, container-based roles

set -euo pipefail

# Configuration
SCRIPT_NAME="configure_containerd.sh"
LOG_FILE="/var/log/bootstrap.log"
CONTAINERD_CONFIG_DIR="/etc/containerd"
CONTAINERD_CONFIG_FILE="$CONTAINERD_CONFIG_DIR/config.toml"
CONTAINERD_SYSTEMD_DIR="/etc/systemd/system/containerd.service.d"
RUNC_VERSION="v1.1.9"
CNI_VERSION="v1.3.0"

# Logging function
log() {
	local level="$1"
	shift
	echo "$(date '+%Y-%m-%d %H:%M:%S') [$level] $SCRIPT_NAME: $*" | tee -a "$LOG_FILE"
}

# Check if running as root
check_root() {
	if [[ $EUID -ne 0 ]]; then
		log "ERROR" "This script must be run as root"
		exit 1
	fi
}

# Check system architecture
detect_arch() {
	case $(uname -m) in
		x86_64)
			ARCH="amd64"
			;;
		aarch64)
			ARCH="arm64"
			;;
		armv7l)
			ARCH="armhf"
			;;
		*)
			log "ERROR" "Unsupported architecture: $(uname -m)"
			exit 1
			;;
	esac
	log "INFO" "Detected architecture: $ARCH"
}

# Install containerd if not present
install_containerd() {
	if command -v containerd > /dev/null 2>&1; then
		log "INFO" "containerd is already installed: $(containerd --version)"
		return 0
	fi

	log "INFO" "Installing containerd..."

	# Update package list
	apt-get update

	# Install containerd
	apt-get install -y containerd.io

	# Verify installation
	if command -v containerd > /dev/null 2>&1; then
		log "INFO" "containerd installed successfully: $(containerd --version)"
	else
		log "ERROR" "Failed to install containerd"
		exit 1
	fi
}

# Install runc if not present or outdated
install_runc() {
	local current_version=""

	if command -v runc > /dev/null 2>&1; then
		current_version=$(runc --version | head -1 | awk '{print $3}')
		log "INFO" "Current runc version: $current_version"

		# Check if we need to update
		if [[ "$current_version" == "$RUNC_VERSION" ]]; then
			log "INFO" "runc is already at the desired version"
			return 0
		fi
	fi

	log "INFO" "Installing runc version $RUNC_VERSION..."

	# Download and install runc
	local runc_url="https://github.com/opencontainers/runc/releases/download/$RUNC_VERSION/runc.$ARCH"

	curl -L "$runc_url" -o /tmp/runc
	chmod +x /tmp/runc

	# Install runc
	install -m 755 /tmp/runc /usr/local/sbin/runc

	# Clean up
	rm -f /tmp/runc

	# Verify installation
	if command -v runc > /dev/null 2>&1; then
		log "INFO" "runc installed successfully: $(runc --version | head -1)"
	else
		log "ERROR" "Failed to install runc"
		exit 1
	fi
}

# Install CNI plugins
install_cni_plugins() {
	local cni_dir="/opt/cni/bin"

	if [[ -d "$cni_dir" ]] && [[ -n "$(ls -A $cni_dir 2> /dev/null)" ]]; then
		log "INFO" "CNI plugins are already installed in $cni_dir"
		return 0
	fi

	log "INFO" "Installing CNI plugins version $CNI_VERSION..."

	# Create CNI directory
	mkdir -p "$cni_dir"

	# Download CNI plugins
	local cni_url="https://github.com/containernetworking/plugins/releases/download/$CNI_VERSION/cni-plugins-linux-$ARCH-$CNI_VERSION.tgz"

	curl -L "$cni_url" -o /tmp/cni-plugins.tgz

	# Extract CNI plugins
	tar -C "$cni_dir" -xzf /tmp/cni-plugins.tgz

	# Clean up
	rm -f /tmp/cni-plugins.tgz

	# Verify installation
	if [[ -f "$cni_dir/bridge" ]]; then
		log "INFO" "CNI plugins installed successfully"
		ls -la "$cni_dir" | head -5 | while IFS= read -r line; do
			log "INFO" "  $line"
		done
	else
		log "ERROR" "Failed to install CNI plugins"
		exit 1
	fi
}

# Generate containerd configuration
generate_containerd_config() {
	log "INFO" "Generating containerd configuration..."

	# Create containerd config directory
	mkdir -p "$CONTAINERD_CONFIG_DIR"

	# Generate default config
	containerd config default > "$CONTAINERD_CONFIG_FILE.tmp"

	# Customize configuration for Kubernetes
	cat > "$CONTAINERD_CONFIG_FILE" << 'EOF'
# Generated by infrastructure bootstrap system
# Configuration for containerd

version = 2

root = "/var/lib/containerd"
state = "/run/containerd"
plugin_dir = ""
disabled_plugins = []
required_plugins = []
oom_score = 0

[grpc]
  address = "/run/containerd/containerd.sock"
  tcp_address = ""
  tcp_tls_cert = ""
  tcp_tls_key = ""
  uid = 0
  gid = 0
  max_recv_message_size = 16777216
  max_send_message_size = 16777216

[ttrpc]
  address = ""
  uid = 0
  gid = 0

[debug]
  address = ""
  uid = 0
  gid = 0
  level = ""

[metrics]
  address = ""
  grpc_histogram = false

[cgroup]
  path = ""

[timeouts]
  "io.containerd.timeout.shim.cleanup" = "5s"
  "io.containerd.timeout.shim.load" = "5s"
  "io.containerd.timeout.shim.shutdown" = "3s"
  "io.containerd.timeout.task.state" = "2s"

[plugins]
  [plugins."io.containerd.gc.v1.scheduler"]
    pause_threshold = 0.02
    deletion_threshold = 0
    mutation_threshold = 100
    schedule_delay = "0s"
    startup_delay = "100ms"

  [plugins."io.containerd.grpc.v1.cri"]
    disable_tcp_service = true
    stream_server_address = "127.0.0.1"
    stream_server_port = "0"
    stream_idle_timeout = "4h0m0s"
    enable_selinux = false
    selinux_category_range = 1024
    sandbox_image = "registry.k8s.io/pause:3.9"
    stats_collect_period = 10
    systemd_cgroup = false
    enable_tls_streaming = false
    max_container_log_line_size = 16384
    disable_cgroup = false
    disable_apparmor = false
    restrict_oom_score_adj = false
    max_concurrent_downloads = 3
    disable_proc_mount = false
    unset_seccomp_profile = ""
    tolerate_missing_hugetlb_controller = true
    disable_hugetlb_controller = true
    ignore_image_defined_volumes = false
    [plugins."io.containerd.grpc.v1.cri".containerd]
      snapshotter = "overlayfs"
      default_runtime_name = "runc"
      no_pivot = false
      disable_snapshot_annotations = true
      discard_unpacked_layers = false
      [plugins."io.containerd.grpc.v1.cri".containerd.runtimes]
        [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]
          runtime_type = "io.containerd.runc.v2"
          runtime_engine = ""
          runtime_root = ""
          privileged_without_host_devices = false
          base_runtime_spec = ""
          [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc.options]
            SystemdCgroup = true

    [plugins."io.containerd.grpc.v1.cri".cni]
      bin_dir = "/opt/cni/bin"
      conf_dir = "/etc/cni/net.d"
      max_conf_num = 1
      conf_template = ""

    [plugins."io.containerd.grpc.v1.cri".registry]
      config_path = ""
      [plugins."io.containerd.grpc.v1.cri".registry.auths]
      [plugins."io.containerd.grpc.v1.cri".registry.configs]
      [plugins."io.containerd.grpc.v1.cri".registry.headers]
      [plugins."io.containerd.grpc.v1.cri".registry.mirrors]

    [plugins."io.containerd.grpc.v1.cri".image_decryption]
      key_model = ""

    [plugins."io.containerd.grpc.v1.cri".x509_key_pair_streaming]
      tls_cert_file = ""
      tls_private_key_file = ""

  [plugins."io.containerd.internal.v1.opt"]
    path = "/opt/containerd"

  [plugins."io.containerd.internal.v1.restart"]
    interval = "10s"

  [plugins."io.containerd.metadata.v1.bolt"]
    content_sharing_policy = "shared"

  [plugins."io.containerd.monitor.v1.cgroups"]
    no_prometheus = false

  [plugins."io.containerd.runtime.v1.linux"]
    shim = "containerd-shim"
    runtime = "runc"
    runtime_root = ""
    no_shim = false
    shim_debug = false

  [plugins."io.containerd.runtime.v2.task"]
    platforms = ["linux/amd64"]

  [plugins."io.containerd.service.v1.diff-service"]
    default = ["walking"]

  [plugins."io.containerd.snapshotter.v1.devmapper"]
    root_path = ""
    pool_name = ""
    base_image_size = ""
    async_remove = false
EOF

	# Clean up temporary file
	rm -f "$CONTAINERD_CONFIG_FILE.tmp"

	log "INFO" "containerd configuration generated successfully"
}

# Configure systemd for containerd
configure_systemd() {
	log "INFO" "Configuring systemd for containerd..."

	# Create systemd override directory
	mkdir -p "$CONTAINERD_SYSTEMD_DIR"

	# Create systemd override for better resource management
	cat > "$CONTAINERD_SYSTEMD_DIR/override.conf" << 'EOF'
[Service]
# Increase file descriptor limits
LimitNOFILE=1048576
LimitNPROC=1048576

# Increase core file size limit
LimitCORE=infinity

# Memory accounting
MemoryAccounting=yes

# CPU accounting
CPUAccounting=yes

# Block I/O accounting
BlockIOAccounting=yes

# Restart policy
Restart=always
RestartSec=5

# Kill mode
KillMode=process

# Delegate cgroup management
Delegate=yes
EOF

	# Reload systemd daemon
	systemctl daemon-reload

	log "INFO" "systemd configuration completed"
}

# Configure kernel modules for containers
configure_kernel_modules() {
	log "INFO" "Configuring kernel modules for containers..."

	local modules=(
		"overlay"
		"br_netfilter"
	)

	# Load modules immediately
	for module in "${modules[@]}"; do
		if ! lsmod | grep -q "^$module "; then
			log "INFO" "Loading kernel module: $module"
			modprobe "$module"
		else
			log "INFO" "Kernel module already loaded: $module"
		fi
	done

	# Make modules persistent
	cat > /etc/modules-load.d/containerd.conf << 'EOF'
# Kernel modules for containerd
overlay
br_netfilter
EOF

	log "INFO" "Kernel modules configured successfully"
}

# Configure sysctl settings for containers
configure_sysctl() {
	log "INFO" "Configuring sysctl settings for containers..."

	cat > /etc/sysctl.d/99-containerd.conf << 'EOF'
# sysctl settings for containerd and Kubernetes

# Enable IP forwarding
net.ipv4.ip_forward = 1

# Enable bridge netfilter
net.bridge.bridge-nf-call-iptables = 1
net.bridge.bridge-nf-call-ip6tables = 1

# Increase network buffer sizes
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216

# Increase connection tracking limits
net.netfilter.nf_conntrack_max = 1048576

# Disable swap accounting (if not using swap)
vm.swappiness = 0
EOF

	# Apply sysctl settings
	sysctl --system

	log "INFO" "sysctl settings configured successfully"
}

# Start and enable containerd service
start_containerd_service() {
	log "INFO" "Starting and enabling containerd service..."

	# Enable the service
	systemctl enable containerd

	# Start the service
	systemctl start containerd

	# Wait a moment for service to fully start
	sleep 3

	# Check service status
	if systemctl is-active --quiet containerd; then
		log "INFO" "containerd service is running successfully"
	else
		log "ERROR" "containerd service failed to start"
		systemctl status containerd
		exit 1
	fi
}

# Verify containerd configuration
verify_containerd() {
	log "INFO" "Verifying containerd configuration..."

	# Test containerd socket
	if [[ -S /run/containerd/containerd.sock ]]; then
		log "INFO" "✓ containerd socket is available"
	else
		log "ERROR" "✗ containerd socket not found"
		return 1
	fi

	# Test ctr command
	if ctr version > /dev/null 2>&1; then
		log "INFO" "✓ ctr command is working"
		ctr version | while IFS= read -r line; do
			log "INFO" "  $line"
		done
	else
		log "ERROR" "✗ ctr command failed"
		return 1
	fi

	# Test crictl (if available)
	if command -v crictl > /dev/null 2>&1; then
		# Configure crictl to use containerd
		cat > /etc/crictl.yaml << 'EOF'
runtime-endpoint: unix:///run/containerd/containerd.sock
image-endpoint: unix:///run/containerd/containerd.sock
timeout: 10
debug: false
pull-image-on-create: false
disable-pull-on-run: false
EOF

		if crictl info > /dev/null 2>&1; then
			log "INFO" "✓ crictl is working with containerd"
		else
			log "WARN" "crictl available but not working properly"
		fi
	fi

	return 0
}

# Main function
main() {
	log "INFO" "Starting containerd configuration process..."

	# Check prerequisites
	check_root
	detect_arch

	# Install and configure containerd
	install_containerd
	install_runc
	install_cni_plugins
	configure_kernel_modules
	configure_sysctl
	generate_containerd_config
	configure_systemd
	start_containerd_service

	# Verify installation
	if verify_containerd; then
		log "INFO" "containerd configuration completed successfully"
		log "INFO" "containerd is ready for container workloads"
		exit 0
	else
		log "ERROR" "containerd configuration failed verification"
		exit 1
	fi
}

# Handle script interruption
cleanup() {
	log "WARN" "Script interrupted, cleaning up..."
	exit 130
}

trap cleanup SIGINT SIGTERM

# Run main function
main "$@"
